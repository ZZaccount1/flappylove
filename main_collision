--Screen
SCREEN_WIDTH = 500
SCREEN_HEIGHT = 750

--Engine
isDebug = false

--Sleep function
local clock = os.clock
function sleep(n)-- seconds
local t0 = clock()
while clock() - t0 <= n do end
end

--Pipes
firstYPipes = 0

--Physics
gravity = 0.5

isDead = false

function resetPipesPos()
    Pipes.x = Pipes.spawnX
    Pipes.y = love.math.random(Pipes.minY, Pipes.maxY)
end

function resetBird()
    Bird.x = SCREEN_WIDTH / 3
    Bird.y  = SCREEN_HEIGHT / 2
    Bird.dy = 0
end

function love.load()
    love.window.setMode(SCREEN_WIDTH, SCREEN_HEIGHT)

    --require
    wf = require "libraries/windfield"
    require("bird")
    require("pipes")

    --Physics
    world = love.physics.newWorld(0,200,true)

    Bird.b = love.physics.newBody(world, Bird.x, Bird.y, "static")
    Bird.s = love.physics.newCircleShape(Bird.size)
    Bird.f = love.physics.newFixture(Bird.b, Bird.s)

    TopPipe.b = love.physics.newBody(world, TopPipe.x, TopPipe.y, "static")
    TopPipe.s = love.physics.newRectangleShape(Pipes.sizeX, Pipes.sizeY)
    TopPipe.f = love.physics.newFixture(TopPipe.b, TopPipe.s)
    
    if isDebug then
        ball = {}
        ball.b = love.physics.newBody(world, 400,200, "dynamic")  -- set x,y position (400,200) and let it move and hit other objects ("dynamic")
        ball.b:setMass(10)                                        -- make it pretty light
        ball.s = love.physics.newCircleShape(50)                  -- give it a radius of 50
        ball.f = love.physics.newFixture(ball.b, ball.s)          -- connect body to shape
        ball.f:setRestitution(0.4)                                -- make it bouncy
        ball.f:setUserData("Ball")     
        static = {}
        static.b = love.physics.newBody(world, 250,500, "static") -- "static" makes it not move
        static.s = love.physics.newRectangleShape(1000,50)         -- set size to 200,50 (x,y)
        static.f = love.physics.newFixture(static.b, static.s)
        static.f:setUserData("Block")
    end

    --Place bird in the middle of the screen
    Bird.x = SCREEN_WIDTH / 3
    Bird.y  = SCREEN_HEIGHT / 2

    --Pipes
    resetPipesPos()
end

function love.update(dt)
    world:update(dt)
    updatePipesPos()

    if isDead then
        return 0
    end

    if Bird.y + Bird.size > SCREEN_HEIGHT then
        isDead = true
    else
        Bird.dy = Bird.dy + gravity
    end
    
    Bird.y = Bird.y + Bird.dy

    --Pipes
    Pipes.x = Pipes.x - Pipes.speed
    if (Pipes.x < Pipes.deleteX) then
        resetPipesPos()
    end

end

function love.draw()
    --Debug
    if isDebug then
        love.graphics.setColor(0,1,0)
        love.graphics.circle("line", ball.b:getX(),ball.b:getY(), ball.s:getRadius(), 20)
        love.graphics.polygon("line", static.b:getWorldPoints(static.s:getPoints()))
        love.graphics.circle("line", Bird.b:getX(), Bird.b:getY(), ball.s:getRadius())
        love.graphics.setColor(1,1,1)
    end

    --Bird
    love.graphics.circle("fill", Bird.x, Bird.y, Bird.size)

    --Pipes
    
    --TopPipe
    love.graphics.rectangle("fill", TopPipe.x, TopPipe.y, Pipes.sizeX, Pipes.sizeY)

    --BottomPipe
    love.graphics.rectangle("fill", BottomPipe.x, BottomPipe.y, Pipes.sizeX, Pipes.sizeY)

    --Debug, center point
    if isDebug then
        debugPointRadius = 10

        love.graphics.setColor(1,0,0)
        love.graphics.circle("fill", Pipes.x, Pipes.y, debugPointRadius, debugPointRadius)
        love.graphics.setColor(0,0,1)
        love.graphics.circle("fill", Pipes.x, Pipes.y - Pipes.PipesGap / 2 - Pipes.sizeY, debugPointRadius, debugPointRadius)
        love.graphics.circle("fill", Pipes.x, Pipes.y + Pipes.PipesGap / 2, debugPointRadius, debugPointRadius)
        love.graphics.setColor(1,1,1)
    end
end

function love.keypressed(key)
    if key == 'up' then
        Bird.dy = Bird.jumpForce
    end

    if (key == "r" and isDead) then
        isDead = false
        resetBird()
        resetPipesPos()
    end
end